/*
 * Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
 * 
 * On Sat Jan 25 18:07:59 IST 2014
 * 
 */
#include "bluesim_primitives.h"
#include "schedule.h"

#include <cstdlib>
#include <time.h>
#include "bluesim_kernel_api.h"
#include "bs_vcd.h"
#include "bs_reset.h"

#include "mkTbRightLogical.h"

namespace bluesim
{
  
  /* Top-level module instances */
  static MOD_mkTbRightLogical *mkTbRightLogical_instance = NULL;
  
  
  /* Schedule functions */
  
  void schedule_posedge_CLK()
  {
    MOD_mkTbRightLogical &INST_top = *mkTbRightLogical_instance;
    tUInt8 DEF_INST_top_DEF_randomVal_init__h168;
    tUInt8 DEF_INST_top_DEF_randomShift_init__h293;
    tUInt8 DEF_INST_top_DEF_CAN_FIRE_RL_randomVal_initialize;
    tUInt8 DEF_INST_top_DEF_WILL_FIRE_RL_randomVal_initialize;
    tUInt8 DEF_INST_top_DEF_CAN_FIRE_RL_randomShift_initialize;
    tUInt8 DEF_INST_top_DEF_WILL_FIRE_RL_randomShift_initialize;
    tUInt8 DEF_INST_top_DEF_CAN_FIRE_RL_test;
    tUInt8 DEF_INST_top_DEF_WILL_FIRE_RL_test;
    DEF_INST_top_DEF_randomShift_init__h293 = INST_top.INST_randomShift_init.METH_read();
    DEF_INST_top_DEF_CAN_FIRE_RL_randomShift_initialize = !DEF_INST_top_DEF_randomShift_init__h293;
    DEF_INST_top_DEF_WILL_FIRE_RL_randomShift_initialize = DEF_INST_top_DEF_CAN_FIRE_RL_randomShift_initialize;
    DEF_INST_top_DEF_randomVal_init__h168 = INST_top.INST_randomVal_init.METH_read();
    DEF_INST_top_DEF_CAN_FIRE_RL_randomVal_initialize = !DEF_INST_top_DEF_randomVal_init__h168;
    DEF_INST_top_DEF_WILL_FIRE_RL_randomVal_initialize = DEF_INST_top_DEF_CAN_FIRE_RL_randomVal_initialize;
    INST_top.DEF_x__h370 = INST_top.INST_cycle.METH_read();
    INST_top.DEF_cycle_EQ_128___d6 = (INST_top.DEF_x__h370) == 128u;
    DEF_INST_top_DEF_CAN_FIRE_RL_test = INST_top.DEF_cycle_EQ_128___d6 || (DEF_INST_top_DEF_randomVal_init__h168 && DEF_INST_top_DEF_randomShift_init__h293);
    DEF_INST_top_DEF_WILL_FIRE_RL_test = DEF_INST_top_DEF_CAN_FIRE_RL_test;
    if (DEF_INST_top_DEF_WILL_FIRE_RL_test)
      INST_top.RL_test();
    if (DEF_INST_top_DEF_WILL_FIRE_RL_randomVal_initialize)
      INST_top.RL_randomVal_initialize();
    if (DEF_INST_top_DEF_WILL_FIRE_RL_randomShift_initialize)
      INST_top.RL_randomShift_initialize();
    if (do_reset_ticks())
    {
      INST_top.INST_cycle.rst_tick__clk__1((tUInt8)1u);
      INST_top.INST_randomVal_init.rst_tick__clk__1((tUInt8)1u);
      INST_top.INST_randomShift_init.rst_tick__clk__1((tUInt8)1u);
    }
  }
  
  /* Model creation/destruction functions */
  
  void create_model(bool master)
  {
    init_reset_request_counters();
    mkTbRightLogical_instance = new MOD_mkTbRightLogical("top", NULL);
    bk_get_or_define_clock("CLK");
    if (master)
    {
      bk_alter_clock(bk_get_clock_by_name("CLK"), CLK_LOW, false, 0llu, 5llu, 5llu);
      bk_use_default_reset();
    }
    bk_set_clock_event_fn(bk_get_clock_by_name("CLK"),
			  schedule_posedge_CLK,
			  NULL,
			  (tEdgeDirection)(POSEDGE));
    (mkTbRightLogical_instance->set_clk_0)("CLK");
  }
  void destroy_model()
  {
    delete mkTbRightLogical_instance;
    mkTbRightLogical_instance = NULL;
  }
  void reset_model(bool asserted)
  {
    (mkTbRightLogical_instance->reset_RST_N)(asserted ? (tUInt8)0u : (tUInt8)1u);
  }
  void * get_instance()
  {
    return mkTbRightLogical_instance;
  }
  
  /* Fill in version numbers */
  void get_version(unsigned int *year,
		   unsigned int *month,
		   char const **annotation,
		   char const **build)
  {
    *year = 2011u;
    *month = 6u;
    *annotation = "D";
    *build = "24470";
  }
  
  /* Get the model creation time */
  time_t get_creation_time()
  {
    
    /* Sat Jan 25 12:37:59 UTC 2014 */
    return 1390653479llu;
  }
  
  /* Control run-time licensing */
  tUInt64 skip_license_check()
  {
    return 0llu;
  }
  
  /* State dumping function */
  void dump_state()
  {
    (mkTbRightLogical_instance->dump_state)(0u);
  }
  
  /* VCD dumping functions */
  MOD_mkTbRightLogical & mkTbRightLogical_backing()
  {
    static MOD_mkTbRightLogical *instance = NULL;
    if (instance == NULL)
    {
      vcd_set_backing_instance(true);
      instance = new MOD_mkTbRightLogical("top", NULL);
      vcd_set_backing_instance(false);
    }
    return *instance;
  }
  void dump_VCD_defs()
  {
    (mkTbRightLogical_instance->dump_VCD_defs)(vcd_depth);
  }
  void dump_VCD(tVCDDumpType dt)
  {
    (mkTbRightLogical_instance->dump_VCD)(dt, vcd_depth, mkTbRightLogical_backing());
  }
}
